package ua.softserve.academy.kv030.authservice.dao;

import org.slf4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;
import ua.softserve.academy.kv030.authservice.exceptions.DaoLayerException;

import javax.persistence.EntityManager;
import javax.persistence.NoResultException;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.*;
import javax.transaction.Transactional;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

@Repository
public abstract class CrudDAOImpl<T> implements CrudDAO<T> {

    @PersistenceContext
    protected EntityManager manager;

    @Autowired
    public Logger logger;


    private Class<T> elementClass;

    @SuppressWarnings("SpringJavaAutowiringInspection")
    public CrudDAOImpl(Class<T> elementClass) {
        this.elementClass = elementClass;
    }

    /**
     * Method search all the elements of table and return them as a list of entity objects
     * @return list of entities which from database
     * */
    @Transactional
    @Override
    public List<T> findAll() {
        CriteriaBuilder criteriaBuilder = manager.getCriteriaBuilder();
        CriteriaQuery<T> criteriaQuery = criteriaBuilder.createQuery(elementClass);
        Root<T> elementRoot = criteriaQuery.from(elementClass);
        criteriaQuery.select(elementRoot);
        List<T> elements = manager.createQuery(criteriaQuery).getResultList();

        if (elements == null) {
            return Collections.emptyList();
        }

        return elements;
    }

    /**
     * Method consumes the entity object and update changed fields in database
     * @param item entity object to be updated in database
     * @return update entity object
     */
    @Transactional
    @Override
    public T update(T item) {
        manager.merge(item);
        return item;
    }

    /**
     * Method consumes the entity object and delete it from database
     * @param item entity object to be deleted in database
     * @return <tt>true</tt> if this object was deleted from database successfully
     */
    @Transactional
    @Override
    public boolean delete(T item) {
        manager.remove(manager.contains(item) ? item : manager.merge(item));
        return true;
    }

    /**
     * Method consumes the id of entity object and return it wrapped in optional object if entity exists
     * else return empty optional
     * @param id identifier of entity object to be searched in database
     * @return wrapped entity object in optional one
     */
    @Transactional
    @Override
    public Optional<T> findElementById(Long id) {
        T element;

        element = manager.find(elementClass, id);

        if (element != null) {
            return Optional.of(element);
        }

        return Optional.empty();
    }


    /**
     * Method consumes the entity object and insert it to the database as a row
     * return the entity of this object with id generated by database
     * @param item entity object to be inserted in database
     * @return inserted object with generated identifier
     */
    @Transactional
    @Override
    public T insert(T item) {
        manager.persist(item);
        return item;
    }

    /**
     * This method counts entities in database table.
     * @return number of entities in database table
     */
    @Override
    public Long count() {
        CriteriaBuilder criteriaBuilder = manager.getCriteriaBuilder();
        CriteriaQuery<Long> criteriaQuery = criteriaBuilder.createQuery(Long.class);
        Root<T> elementRoot = criteriaQuery.from(elementClass);
        criteriaQuery.select(criteriaBuilder.count(elementRoot));

        try {
            Long count = manager.createQuery(criteriaQuery).getSingleResult();
            return count;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            throw new DaoLayerException(e.getMessage());
        }
    }

    /**
     * This method checks whether specified field value of an entity exists in database.
     * @return <tt>true</tt> if value exists, <tt>false</tt> otherwise
     */
    @Override
    public <F> Boolean containsFieldEqual(String fieldName, F fieldValue) {

        /*CriteriaBuilder criteriaBuilder = manager.getCriteriaBuilder();

        CriteriaQuery<Boolean> criteriaQuery = criteriaBuilder.createQuery(Boolean.class);
        criteriaQuery.from(elementClass);
        criteriaQuery.select(criteriaBuilder.literal(true));

        Subquery<T> subquery = criteriaQuery.subquery(elementClass);
        Root<T> subRootEntity = subquery.from(elementClass);
        subquery.select(subRootEntity);

        Path<?> attributePath = subRootEntity.get(fieldName);
        Predicate predicate = criteriaBuilder.equal(attributePath, criteriaBuilder.literal(fieldValue));
        subquery.where(predicate);
        criteriaQuery.where(criteriaBuilder.exists(subquery));

        TypedQuery<Boolean> typedQuery = manager.createQuery(criteriaQuery);

        try {
            return typedQuery.getSingleResult();
        } catch (NoResultException e) {
            logger.debug(e.getMessage());
            return false;
        } catch (Exception ex) {
            logger.error(ex.getMessage(), ex);
            throw new DaoLayerException(ex.getMessage());
        }*/

        CriteriaBuilder criteriaBuilder = manager.getCriteriaBuilder();
        CriteriaQuery<Boolean> criteriaQuery = criteriaBuilder.createQuery(Boolean.class);
        Root<T> root = criteriaQuery.from(elementClass); // needed to validate the jpa criteria

        Subquery<T> subquery = criteriaQuery.subquery(elementClass);
        Root<T> subroot = subquery.from(elementClass);
        subquery.select(subroot);

        Predicate subPredicate = criteriaBuilder.equal(subroot.get(fieldName), fieldValue);
        subquery.where(subPredicate);

        Predicate predicateExists = criteriaBuilder.exists(subquery);

        CriteriaBuilder.Case<Boolean> booleanCase = criteriaBuilder.selectCase();
        Expression<Boolean> booleanExpression =
                booleanCase.when(predicateExists,true)
                        .otherwise(false);

        criteriaQuery.select(booleanExpression);

        TypedQuery<Boolean> typedQuery = manager.createQuery(criteriaQuery);

        try {
            return typedQuery.getSingleResult();
        } catch (Exception ex) {
            logger.error(ex.getMessage(), ex);
            throw new DaoLayerException(ex.getMessage());
        }
    }

    /**
     * This method returns a list of database entities by value of the entity field between two specified value.
     *
     * @param fieldName a filed name of an entity to search by in database
     * @param fieldValueStart a filed value that a database entity has to have more than or equal
     * @param fieldValueEnd a filed value that a database entity has to have less than or equal
     * @return a list of entities from database
     * @throws DaoLayerException
     * */
    @Override
    public <F extends Comparable> List<T> findAllByFieldBetween(String fieldName, F fieldValueStart, F fieldValueEnd) {
        CriteriaBuilder criteriaBuilder = manager.getCriteriaBuilder();
        CriteriaQuery<T> criteriaQuery = criteriaBuilder.createQuery(elementClass);
        Root<T> elementRoot = criteriaQuery.from(elementClass);
        criteriaQuery.select(elementRoot).where(criteriaBuilder.between(elementRoot.get(fieldName), fieldValueStart, fieldValueEnd));

        try {
            List<T> elements = manager.createQuery(criteriaQuery).getResultList();
            return (elements == null) ? Collections.emptyList() : elements;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            throw new DaoLayerException(e.getMessage());
        }
    }

    /**
     * This method returns a single entity from database found by unique value of the entity field.
     *
     * @param fieldName a filed name of an entity to search by in database
     * @param fieldValue a filed value that a database entity has to have
     * @return optional of an entity from database
     * @throws DaoLayerException
     * */
    @Override
    public <F> Optional<T> findOneByFieldEqual(String fieldName, F fieldValue) {
        CriteriaBuilder criteriaBuilder = manager.getCriteriaBuilder();
        CriteriaQuery<T> criteriaQuery = criteriaBuilder.createQuery(elementClass);
        Root<T> elementRoot = criteriaQuery.from(elementClass);
        criteriaQuery.select(elementRoot).where(criteriaBuilder.equal(elementRoot.get(fieldName), fieldValue));

        try {
            T element = manager.createQuery(criteriaQuery).getSingleResult();
            return Optional.of(element);
        } catch (NoResultException e1) {
            logger.debug(e1.getMessage());
            return Optional.empty();
        } catch (Exception e2) {
            logger.error(e2.getMessage(), e2);
            throw new DaoLayerException(e2.getMessage());
        }
    }

    /**
     * This method returns a list of database entities with filed value equals to the specified field value.
     *
     * @param fieldName a filed name of an entity to search by in database
     * @param fieldValue a filed value that a database entity has to have
     * @return a list of entities found in database
     * @throws DaoLayerException
     * */
    @Override
    public <F> List<T> findAllByFieldEqual(String fieldName, F fieldValue) {
        CriteriaBuilder criteriaBuilder = manager.getCriteriaBuilder();
        CriteriaQuery<T> criteriaQuery = criteriaBuilder.createQuery(elementClass);
        Root<T> elementRoot = criteriaQuery.from(elementClass);
        criteriaQuery.select(elementRoot).where(criteriaBuilder.equal(elementRoot.get(fieldName), fieldValue));
        List<T> elements = null;

        try {
            elements = manager.createQuery(criteriaQuery).getResultList();
            return (elements == null) ? Collections.emptyList() : elements;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            throw new DaoLayerException(e.getMessage());
        }
    }

    /**
     * This method returns a list of database entities, defined by offset to retrieve results from and by page size.
     *
     * @param offset a first result entity to be retrieved from the database, starts from 0
     * @param pageSize max number of results to retrieve
     * @param fieldToSortBy an entity field by which to sort results
     * @param order an ascending or descending order to sort results
     * @return a list of entities from database
     * @throws DaoLayerException
     * */
    @Override
    public List<T> findAllByOffsetByPageSizeSortedByField(int offset, int pageSize, String fieldToSortBy, SortingOrderEnum order) {

        CriteriaBuilder criteriaBuilder = manager.getCriteriaBuilder();
        CriteriaQuery<T> criteriaQuery = criteriaBuilder.createQuery(elementClass);
        Root<T> from = criteriaQuery.from(elementClass);
        CriteriaQuery<T> select = criteriaQuery.select(from);
        switch(order) {
            case ASC:
                criteriaQuery.orderBy(criteriaBuilder.asc(from.get(fieldToSortBy)));
                break;
            case DESC:
                criteriaQuery.orderBy(criteriaBuilder.desc(from.get(fieldToSortBy)));
                break;
            default:
                throw new DaoLayerException("order must be ASC or DESC of type SortingOrderEnum");
        }
        TypedQuery<T> typedQuery = manager.createQuery(select);
        typedQuery.setFirstResult(offset);
        typedQuery.setMaxResults(pageSize);

        try {
            List<T> elements = typedQuery.getResultList();
            return (elements == null) ? Collections.emptyList() : elements;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            throw new DaoLayerException(e.getMessage());
        }
    }
}